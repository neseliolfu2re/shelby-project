/* tslint:disable */
/* eslint-disable */
/**
 * Wrapper to decompile script in its serialized form and wrap it with wasm errors.
 */
export function generate_batched_call_payload_wasm(script: Uint8Array): MoveFunctionCall[];
export class AllocatedLocal {
  private constructor();
  free(): void;
}
export class BuilderCall {
  private constructor();
  free(): void;
}
/**
 * WASM Representation of CallArgument. This is because wasm_bindgen can only support c-style enum.
 */
export class CallArgument {
  private constructor();
  free(): void;
  static newBytes(bytes: Uint8Array): CallArgument;
  static newSigner(signer_idx: number): CallArgument;
  borrow(): CallArgument;
  borrowMut(): CallArgument;
  copy(): CallArgument;
}
/**
 * Calling a Move function.
 *
 * Similar to a public entry function call, but the arguments could specified as `CallArgument`,
 * which can be a return value of a previous `MoveFunctionCall`.
 */
export class MoveFunctionCall {
  private constructor();
  free(): void;
}
/**
 * Representing a returned value from a previous list of `MoveFunctionCall`s.
 */
export class PreviousResult {
  private constructor();
  free(): void;
}
export class TransactionComposer {
  private constructor();
  free(): void;
  /**
   * Create a builder with one distinct signer available. This should be the default configuration.
   */
  static single_signer(): TransactionComposer;
  /**
   * Create a builder with one signer needed for script. This would be needed for multi-agent
   * transaction where multiple signers are present.
   */
  static multi_signer(signer_count: number): TransactionComposer;
  /**
   * Consume the builder and generate a serialized script with calls in the builder.
   */
  generate_batched_calls(with_metadata: boolean): Uint8Array;
  store_module(module_bytes: Uint8Array): string;
  /**
   * This would be the core api for the `TransactionComposer`. The function would:
   * - add the function call to the builder
   * - allocate the locals and parameters needed for this function call
   * - return the arguments back to the caller which could be passed into subsequent calls
   *   into `add_batched_call`.
   *
   * This function would also check for the ability and type safety when passing values
   * into the function call, and will abort if there's a violation.
   */
  add_batched_call(module: string, _function: string, ty_args: string[], args: CallArgument[]): CallArgument[];
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_allocatedlocal_free: (a: number, b: number) => void;
  readonly __wbg_buildercall_free: (a: number, b: number) => void;
  readonly __wbg_transactioncomposer_free: (a: number, b: number) => void;
  readonly transactioncomposer_single_signer: () => number;
  readonly transactioncomposer_multi_signer: (a: number) => number;
  readonly transactioncomposer_generate_batched_calls: (a: number, b: number) => [number, number, number, number];
  readonly transactioncomposer_store_module: (a: number, b: number, c: number) => [number, number, number, number];
  readonly transactioncomposer_add_batched_call: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number, number, number];
  readonly __wbg_callargument_free: (a: number, b: number) => void;
  readonly callargument_newBytes: (a: number, b: number) => number;
  readonly callargument_newSigner: (a: number) => number;
  readonly callargument_borrow: (a: number) => [number, number, number];
  readonly callargument_borrowMut: (a: number) => [number, number, number];
  readonly callargument_copy: (a: number) => [number, number, number];
  readonly generate_batched_call_payload_wasm: (a: number, b: number) => [number, number, number, number];
  readonly __wbg_previousresult_free: (a: number, b: number) => void;
  readonly __wbg_movefunctioncall_free: (a: number, b: number) => void;
  readonly __wbindgen_export_0: WebAssembly.Table;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __externref_table_dealloc: (a: number) => void;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __externref_table_alloc: () => number;
  readonly __externref_drop_slice: (a: number, b: number) => void;
  readonly __wbindgen_start: () => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
*
* @returns {InitOutput}
*/
export function initSync(module: { module: SyncInitInput } | SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<InitOutput>;
